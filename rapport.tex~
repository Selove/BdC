\documentclass[a4paper,10pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage[top=2cm, bottom=2cm, left=2cm, right=2cm]{geometry}
\usepackage{listings}
\lstset{
basicstyle=\small,
language=Prolog,
frame=single,
}


\usepackage[dvips]{hyperref}

\title{Rapport \\ Bases de Connaissances}
\author{Selove OKE CODJO \\ Solène EHOLIE}
\date{04/06/2014}

\begin{document}

 \maketitle
 \newpage
 \tableofcontents
 \newpage
 \section{Introduction}
 
 
 \section{Rendu des programmes r\'{e}alis\'{e}s en TP}
 
  \subsection{TP1 : generation de plan}
  
  Le but du TP1 était de prendre en main la programmation en prolog \`{a} travers un problème simple mettant en scène un agent et un objet. L'agent
  est capable de se d\'{e}placer d'un point a \`{a} un point b, de prendre l'objet et de le poser. Il va donc falloir g\'{e}n\'{e}rer le plan \`{a}
  suivre par l'agent pour aller d'une certaine situation \`{a} une autre
  
  
   \subsubsection{R\'{e}solution du probl\`{e}me}
  La premi\`{e}re chose \`{a} faire \'{e}tait de d\'{e}finir les diff\'{e}rentes actions dont notre agent est capable.
  Une action \'{e}tant d\'{e}finie par une specification, une liste de conditions n\'{e}cessaire \`{a} son accomplissement, une liste de propri\'{e}t\'{e}s qui ne seront
  plus vraies et une liste de nouvelles propri\'{e}t\'{e}s.
  
  Ainsi, on d\'{e}finit l'action aller demandant \`{a} un robot de se deplacer d'un point X \`{a} un point Y. il faut donc que le robot soit en X,
  propri\'{e}t\'{e} qui deviendra fausse apr\`{e}s le déplacement o\`{u} il se retrouve en Y. La d\'{e}finition est donn\'{e}e ci-dessous.
  \begin{lstlisting}
   action(aller(robot,X,Y), 
          [lieu(robot) = X], 
          [lieu(robot) = X], [lieu(robot) = Y]) :-
	      member(X,[a,b]), member(Y,[a,b]), X \= Y.
  \end{lstlisting}
  Ensuite on d\'{e}finit prendre, il faut que le robot et la boite soient au m\^{e}me endroit et que la main du robot soit libre, bien s\^{u}r
  la main n'est plus libre apr\`{e} l'action et l'objet n'est plus \`{a} l'endroit o\`{u} il \'{e}tait mais dans la main du robot.
  \begin{lstlisting}
   action(prendre(robot,O), 
          [lieu(robot) = L, lieu(O) = L, libre(main(robot))], 
          [libre(main(robot)), lieu(O)=L], 
          [lieu(O)=main(robot)]) :-
	      member(L,[a,b]), member(O,[boite]).
  \end{lstlisting}
  Enfin, on d\'{e}finit poser, l'objet doit \^{e}tre dans la main du robot avant de la quitter et se retrouver \`{a} la m\^{e}me position que le robot.
  \begin{lstlisting}
   action(poser(robot,O), 
          [lieu(robot) = L, lieu(O) = main(robot)], 
          [lieu(O)=main(robot)], 
          [lieu(O) = L, libre(main(robot))]) :- 
	      member(L, [a,b]), member(O, [boite]).
  \end{lstlisting}
  Il faut maintenant decrire ce que c'est qu'une transition entre un \'{e}tat E et un autre F, cele consiste juste en la réalisation d'une action dans
  E, il faut donc que les conditions soient v\'{e}rifi\'{e}es en E, il faut supprimer les propri\'{e}t\'{e}s qui ne seront plus v\'{e}rifi\'{e}es et 
  ajouter les nouvelles. On a donc :
  \begin{lstlisting}
   transition(A,E,F) :- action(A, C, S, AJ), verifcond(C,E), 
			 suppress(S, E, EI), ajouter(AJ,EI,F).
  \end{lstlisting}
  La fonction verifcond(C,E) v\'{e}rifi\'{e}e l'inclusion de C dans E, suppress(S, E, EI) supprime S de E pour donner EI et ajouter(AJ,EI,F)
  ajoute AJ \`{a} EI pour obtenir F.
  \begin{lstlisting}
   %verifcond(C,E) est l inclusion de C dans E
   verifcond([], _). %la liste vide est toujours incluse
   verifcond([C|LC], L) :- member(C,L), verifcond(LC,L).
  \end{lstlisting}
  \begin{lstlisting}
   %suppression
   suppress([],L,L).
   suppress([X|Y], Z, T) :- delete(Z,X,U), suppress(Y,U,T).
  \end{lstlisting}
  \begin{lstlisting}
   %ajout
   ajouter(AJ,E,F) :- union(AJ,E,F).
  \end{lstlisting}
  Pour finir, il nous faut generer un plan d'une certaine profondeur, et une autre qui nous permet d'entrer la profondeur que l'on veut sans avoir
  \`{a} modifier le code ces deux fonctions sont données ci-dessous :
  \begin{lstlisting}
   %generation de plan
   genere(E,F,[A],1):-
      transition(A,E,F).

   genere(EI,EF,[ACT|PLAN],M):-
      M > 1, transition(ACT,EI,E), N is M-1, 
      between(1,N,P), genere(E,EF,PLAN,P).
  \end{lstlisting}
  \begin{lstlisting}
   planifier(Plan) :-
      init(E),
      but(B),
      nl,
      write(' Profondeur limite : '),
      read(Prof),
      nl,
      genere(E,F,Plan,Prof),
      verifcond(B,F).
  \end{lstlisting}
   \subsubsection{Tests}
   
  \subsection{TP2 : planification multi-agents}
 L'objectif ici \'{e}tait de faire de la planification comme au TP1 à la seule différence qu'il y a ici plusieurs agents différents.
 Ce qui offre un nombre de situations plus \'{e}lev\'{e} et des cas plus complexes \`{a} traiter.
 
   \subsubsection{R\'{e}solution du probl\`{e}me}
   La diff\'{e}rence principale avec le TP1 r\'{e}side dans la d\'{e}finition des actions. On a plusieurs agents qui ont des capacit\'{e}s diff\'{e}rentes, il faudra donc
   sp\'{e}cifier les agents capables d'effectuer telle ou telle autre action. De plus, concernant les lieux, un objet peut se retrouver dans la 'main' de tel ou tel autre agent,
   il faut donc un moyen de distinguer les 'mains'. Les objets peuvent aussi \^{e}tre empil\'{e}s les uns sur les autres. La d\'{e}finition des action est donc un peu plus complexe
   comme nous allons le voir dans ce qui suit.
   
   La premi\`{e}re action d\'{e}finie est $aller\_a\_vide(R,Ld,La)$. C'est la possibilit\'{e} pour un agent de se d\'{e}placer de la position Ld vers la position La sans 
   transporter d'objet, ce qui constitue la seule diff\'{e}rence avec l'action aller du TP1. Seul le robot1 sait le faire.
   \begin{lstlisting}
   action( aller_a_vide(R,Ld,La),
	[position(R) = Ld, libre(main(R))],
	[position(R) = Ld],
	[position(R) = La] ) :-
	member(Ld,[a,b,c]), member(La,[a,b,c]), member(R,[robo1]), Ld \= La.
   \end{lstlisting}
   Ensuite il fallait d\'{e}finir $transporter(R,Ld,La,O)$ qui permet \`{a} un agent R d'aller de la position Ld \`{a} la position La en transportant l'objet O.
   Il faut donc que l'agent et l'objet soient en Ld et qu'il tienne l'objet O. Apr\`{e}s, ils se retrouvent tout les deux en La. Le code est donn\'{e} dans l'encadré ci-dessous.
   \begin{lstlisting}
   action( transporter(R,Ld,La,O),
	[position(R) = Ld, position(O) = Ld, lieu(O) = main(R)],
	[position(R) = Ld, position(O) = Ld],
	[position(R) = La, position(O) = La] ) :-
	member(Ld,[a,b,c]), member(La,[a,b,c]), member(R,[robo1]), 
	member(O,[cube1,cube2]), Ld \= La.
   \end{lstlisting}
   L'action $attraper(R,O,L)$ d\'{e}crit le fait, pour un agent R, de prendre un objetO sur la table de la position L. Il faut que l'objet soit accessible, c'est \`{a} dire qu'il n'y ait pas d'objet au dessus,
   l'objet n'est donc plus sur la table, n'est plus accessible et la main du robot n'est plus libre. L'objet se trouve maintenant dans la main du robot R.
   Elle peut \^{e}tre ex\'{e}cut\'{e}e par les trois robots.
   \begin{lstlisting}
   action( attraper(R,O,L),
	[position(R) = L, position(O) = L, sur(O,table(L)), 
	accessible(O), libre(main(R))],
	[sur(O,table(L)), accessible(O), libre(main(R))],
	[lieu(O) = main(R)] ) :-
	member(L,[a,b,c]), member(R,[robo1, robo2, robo3]), member(O,[cube1,cube2]).
   \end{lstlisting}
   L'action $saisir(R,O,L)$ permet \`{a} un robot R de prendre un objet O qui se trouve en haut d'une pile et au m\^{e}me lieu L que le robot.
   La main du robot doit être libre et l'objet doit se trouver sur un autre Osous. Bien s\^{u}, apr\`{e}s l'action, O ne se trouve plus sur Osous,
   il n'est plus accessible et la main du robot n'est plus libre. O est maintenant dans la main de R, et l'objet qui \'{e}tait en dessous est d\'{e}sormais accessible.
   Seuls les robots 2 et 3 peuvent le faire.
   \begin{lstlisting}
   action( saisir(R,O,L),
	[position(R) = L, position(O) = L, sur(O,Osous), 
	accessible(O), libre(main(R))],
	[sur(O,Osous), accessible(O), libre(main(R))],
	[lieu(O) = main(R), accessible(Osous)] ) :-
	member(L,[a,b,c]), member(R,[robo2, robo3]), 
	member(O,[cube1,cube2]), member(Osous,[cube1,cube2]), O \= Osous.
   \end{lstlisting}
   Les actions $deposer(R,O,L)$ et $empiler(R,Osur,Osous,L)$ sont les actions contraires respectivement à $attraper(R,O,L)$ et $saisir(R,O,L)$, on ne détaillera
   pas leur fonctionnement. Il suffit de d\'{e}rouler les sc\'{e}narios dans le sens oppos\'{e} \`{a} ceux d'attraper et saisir.
   \begin{lstlisting}
   action( deposer(R,O,L),
	[position(R) = L, position(O) = L, lieu(O) = main(R)],
	[lieu(O) = main(R)],
	[sur(O,table(L)), accessible(O), libre(main(R))] ) :-
	member(L,[a,b,c]), member(R,[robo1, robo2, robo3]),member(O,[cube1,cube2]).
   \end{lstlisting}
   \begin{lstlisting}
   action( empiler(R,Osur,Osous,L),
	[position(R) = L, position(Osur) = L, lieu(Osur) = main(R), accessible(Osous)],
	[lieu(Osur) = main(R), accessible(Osous)],
	[sur(Osur,Osous), accessible(Osur), libre(main(R))] ) :-
	member(L,[a,b,c]), member(R,[robo2, robo3]), 
	member(Osur,[cube1,cube2]), member(Osous,[cube1,cube2]), Osur \= Osous.
   \end{lstlisting}
   \subsubsection{Tests}
   
  \subsection{TP3 : g\'{e}n\'{e}rateur-d\'{e}monstrateur en logique modale}
  Au cours de cette s\'{e}ance, il fallait \'{e}crire un programme capable de d\'{e}montrer des th\'{e}or\`{e}mes sur une logique modale.
  
   \subsubsection{R\'{e}solution du probl\`{e}me}
   Dans un premier temps il fallait d\'{e}finir le fait qu'une proposition P soit satisfaite dans un monde W
   \subsubsection{Tests}
   
  \subsection{TP4 : g\'{e}n\'{e}rateur de plan en logique modale}
  
   \subsubsection{R\'{e}solution du probl\`{e}me}
   \subsubsection{Tests}
   
   
 \section{Travaux r\'{e}alis\'{e}s lors du bureau d'\'{e}tude}
 
  \subsection{Etude de Lm\{p\} }
  
  \subsection{Etude de Lm\{E0\}}
  
  \subsection{Etude d'autres logiques}
  
 \section{Conclusion}
    
\end{document}