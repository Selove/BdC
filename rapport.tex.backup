\documentclass[a4paper,10pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage[top=2cm, bottom=2cm, left=2cm, right=2cm]{geometry}
\usepackage{listings}
\lstset{
basicstyle=\small,
language=Prolog,
frame=single,
}


\usepackage[dvips]{hyperref}

\title{Rapport \\ Bases de Connaissances}
\author{Selove OKE CODJO \\ Solène EHOLIE}
\date{04/06/2014}

\begin{document}

 \maketitle
 \newpage
 \tableofcontents
 \newpage
 \section{Introduction}
 
 
 \section{Rendu des programmes r\'{e}alis\'{e}s en TP}
 
  \subsection{TP1 : generation de plan}
  
  Le but du TP1 était de prendre en main la programmation en prolog \`{a} travers un problème simple mettant en scène un agent et un objet. L'agent
  est capable de se d\'{e}placer d'un point a \`{a} un point b, de prendre l'objet et de le poser. Il va donc falloir g\'{e}n\'{e}rer le plan \`{a}
  suivre par l'agent pour aller d'une certaine situation \`{a} une autre
  
  
   \subsubsection{R\'{e}solution du probl\`{e}me}
  La premi\`{e}re chose \`{a} faire \'{e}tait de d\'{e}finir les diff\'{e}rentes actions dont notre agent est capable.
  Une action \'{e}tant d\'{e}finie par une specification, une liste de conditions n\'{e}cessaire \`{a} son accomplissement, une liste de propri\'{e}t\'{e}s qui ne seront
  plus vraies et une liste de nouvelles propri\'{e}t\'{e}s.
  
  Ainsi, on d\'{e}finit l'action aller demandant \`{a} un robot de se deplacer d'un point X \`{a} un point Y. il faut donc que le robot soit en X,
  propri\'{e}t\'{e} qui deviendra fausse apr\`{e}s le déplacement o\`{u} il se retrouve en Y. La d\'{e}finition est donn\'{e}e ci-dessous.
  \begin{lstlisting}
   action(aller(robot,X,Y), 
          [lieu(robot) = X], 
          [lieu(robot) = X], [lieu(robot) = Y]) :-
	      member(X,[a,b]), member(Y,[a,b]), X \= Y.
  \end{lstlisting}
  Ensuite on d\'{e}finit prendre, il faut que le robot et la boite soient au m\^{e}me endroit et que la main du robot soit libre, bien s\^{u}r
  la main n'est plus libre apr\`{e} l'action et l'objet n'est plus \`{a} l'endroit o\`{u} il \'{e}tait mais dans la main du robot.
  \begin{lstlisting}
   action(prendre(robot,O), 
          [lieu(robot) = L, lieu(O) = L, libre(main(robot))], 
          [libre(main(robot)), lieu(O)=L], 
          [lieu(O)=main(robot)]) :-
	      member(L,[a,b]), member(O,[boite]).
  \end{lstlisting}
  Enfin, on d\'{e}finit poser, l'objet doit \^{e}tre dans la main du robot avant de la quitter et se retrouver \`{a} la m\^{e}me position que le robot.
  \begin{lstlisting}
   action(poser(robot,O), 
          [lieu(robot) = L, lieu(O) = main(robot)], 
          [lieu(O)=main(robot)], 
          [lieu(O) = L, libre(main(robot))]) :- 
	      member(L, [a,b]), member(O, [boite]).
  \end{lstlisting}
  Il faut maintenant decrire ce que c'est qu'une transition entre un \'{e}tat E et un autre F, cele consiste juste en la réalisation d'une action dans
  E, il faut donc que les conditions soient v\'{e}rifi\'{e}es en E, il faut supprimer les propri\'{e}t\'{e}s qui ne seront plus v\'{e}rifi\'{e}es et 
  ajouter les nouvelles. On a donc :
  \begin{lstlisting}
   transition(A,E,F) :- action(A, C, S, AJ), verifcond(C,E), 
			 suppress(S, E, EI), ajouter(AJ,EI,F).
  \end{lstlisting}
  La fonction verifcond(C,E) v\'{e}rifi\'{e}e l'inclusion de C dans E, suppress(S, E, EI) supprime S de E pour donner EI et ajouter(AJ,EI,F)
  ajoute AJ \`{a} EI pour obtenir F.
  \begin{lstlisting}
   %verifcond(C,E) est l inclusion de C dans E
   verifcond([], _). %la liste vide est toujours incluse
   verifcond([C|LC], L) :- member(C,L), verifcond(LC,L).
  \end{lstlisting}
  \begin{lstlisting}
   %suppression
   suppress([],L,L).
   suppress([X|Y], Z, T) :- delete(Z,X,U), suppress(Y,U,T).
  \end{lstlisting}
  \begin{lstlisting}
   %ajout
   ajouter(AJ,E,F) :- union(AJ,E,F).
  \end{lstlisting}
  Pour finir, il nous faut generer un plan d'une certaine profondeur, et une autre qui nous permet d'entrer la profondeur que l'on veut sans avoir
  \`{a} modifier le code ces deux fonctions sont données ci-dessous :
  \begin{lstlisting}
   %generation de plan
   genere(E,F,[A],1):-
      transition(A,E,F).

   genere(EI,EF,[ACT|PLAN],M):-
      M > 1, transition(ACT,EI,E), N is M-1, 
      between(1,N,P), genere(E,EF,PLAN,P).
  \end{lstlisting}
  \begin{lstlisting}
   planifier(Plan) :-
      init(E),
      but(B),
      nl,
      write(' Profondeur limite : '),
      read(Prof),
      nl,
      genere(E,F,Plan,Prof),
      verifcond(B,F).
  \end{lstlisting}
   \subsubsection{Tests}
   
  \subsection{TP2 : planification multi-agents}
 L'objectif ici \'{e}tait de faire de la planification comme au TP1 à la seule différence qu'il y a ici plusieurs agents différents.
 Ce qui offre un nombre de situations plus \'{e}lev\'{e} et des cas plus complexes \`{a} traiter.
 
   \subsubsection{R\'{e}solution du probl\`{e}me}
   La diff\'{e}rence principale avec le TP1 r\'{e}side dans la d\'{e}finition des actions. On a plusieurs agents qui ont des capacit\'{e}s diff\'{e}rentes, il faudra donc
   sp\'{e}cifier les agents capables d'effectuer telle ou telle autre action. De plus, concernant les lieux, un objet peut se retrouver dans la 'main' de tel ou tel autre agent,
   il faut donc un moyen de distinguer les 'mains'. Les objets peuvent aussi \^{e}tre empil\'{e}s les uns sur les autres. La d\'{e}finition des action est donc un peu plus complexe
   comme nous allons le voir dans ce qui suit.
   
   La premi\`{e}re action d\'{e}finie est $aller\_a\_vide(R,Ld,La)$. C'est la possibilit\'{e} pour un agent de se d\'{e}placer de la position Ld vers la position La sans 
   transporter d'objet, ce qui constitue la seule diff\'{e}rence avec l'action aller du TP1. Seul le robot1 sait le faire.
   \begin{lstlisting}
   action( aller_a_vide(R,Ld,La),
	[position(R) = Ld, libre(main(R))],
	[position(R) = Ld],
	[position(R) = La] ) :-
	member(Ld,[a,b,c]), member(La,[a,b,c]), member(R,[robo1]), Ld \= La.
   \end{lstlisting}
   Ensuite il fallait d\'{e}finir $transporter(R,Ld,La,O)$ qui permet \`{a} un agent R d'aller de la position Ld \`{a} la position La en transportant l'objet O.
   Il faut donc que l'agent et l'objet soient en Ld et qu'il tienne l'objet O. Apr\`{e}s, ils se retrouvent tout les deux en La. Le code est donn\'{e} dans l'encadré ci-dessous.
   \begin{lstlisting}
   action( transporter(R,Ld,La,O),
	[position(R) = Ld, position(O) = Ld, lieu(O) = main(R)],
	[position(R) = Ld, position(O) = Ld],
	[position(R) = La, position(O) = La] ) :-
	member(Ld,[a,b,c]), member(La,[a,b,c]), member(R,[robo1]), 
	member(O,[cube1,cube2]), Ld \= La.
   \end{lstlisting}
   L'action $attraper(R,O,L)$ d\'{e}crit le fait, pour un agent R, de prendre un objetO sur la table de la position L. Il faut que l'objet soit accessible, c'est \`{a} dire qu'il n'y ait pas d'objet au dessus,
   l'objet n'est donc plus sur la table, n'est plus accessible et la main du robot n'est plus libre. L'objet se trouve maintenant dans la main du robot R.
   Elle peut \^{e}tre ex\'{e}cut\'{e}e par les trois robots.
   \begin{lstlisting}
   action( attraper(R,O,L),
	[position(R) = L, position(O) = L, sur(O,table(L)), 
	accessible(O), libre(main(R))],
	[sur(O,table(L)), accessible(O), libre(main(R))],
	[lieu(O) = main(R)] ) :-
	member(L,[a,b,c]), member(R,[robo1, robo2, robo3]), member(O,[cube1,cube2]).
   \end{lstlisting}
   L'action $saisir(R,O,L)$ permet \`{a} un robot R de prendre un objet O qui se trouve en haut d'une pile et au m\^{e}me lieu L que le robot.
   La main du robot doit être libre et l'objet doit se trouver sur un autre Osous. Bien s\^{u}, apr\`{e}s l'action, O ne se trouve plus sur Osous,
   il n'est plus accessible et la main du robot n'est plus libre. O est maintenant dans la main de R, et l'objet qui \'{e}tait en dessous est d\'{e}sormais accessible.
   Seuls les robots 2 et 3 peuvent le faire.
   \begin{lstlisting}
   action( saisir(R,O,L),
	[position(R) = L, position(O) = L, sur(O,Osous), 
	accessible(O), libre(main(R))],
	[sur(O,Osous), accessible(O), libre(main(R))],
	[lieu(O) = main(R), accessible(Osous)] ) :-
	member(L,[a,b,c]), member(R,[robo2, robo3]), 
	member(O,[cube1,cube2]), member(Osous,[cube1,cube2]), O \= Osous.
   \end{lstlisting}
   Les actions $deposer(R,O,L)$ et $empiler(R,Osur,Osous,L)$ sont les actions contraires respectivement à $attraper(R,O,L)$ et $saisir(R,O,L)$, 
   on ne détaillera pas leur fonctionnement. Il suffit de d\'{e}rouler les sc\'{e}narios dans le sens oppos\'{e} \`{a} ceux d'attraper et saisir.
   \begin{lstlisting}
   action( deposer(R,O,L),
	[position(R) = L, position(O) = L, lieu(O) = main(R)],
	[lieu(O) = main(R)],
	[sur(O,table(L)), accessible(O), libre(main(R))] ) :-
	member(L,[a,b,c]), member(R,[robo1, robo2, robo3]),member(O,[cube1,cube2]).
   \end{lstlisting}
   \begin{lstlisting}
   action( empiler(R,Osur,Osous,L),
	[position(R) = L, position(Osur) = L, lieu(Osur) = main(R), accessible(Osous)],
	[lieu(Osur) = main(R), accessible(Osous)],
	[sur(Osur,Osous), accessible(Osur), libre(main(R))] ) :-
	member(L,[a,b,c]), member(R,[robo2, robo3]), 
	member(Osur,[cube1,cube2]), member(Osous,[cube1,cube2]), Osur \= Osous.
   \end{lstlisting}
   \subsubsection{Tests}
   
  \subsection{TP3 : g\'{e}n\'{e}rateur-d\'{e}monstrateur en logique modale}
  Au cours de cette s\'{e}ance, il fallait \'{e}crire un programme capable de d\'{e}montrer des th\'{e}or\`{e}mes sur une logique modale.
  
   \subsubsection{R\'{e}solution du probl\`{e}me}
   Dans un premier temps il fallait d\'{e}finir le fait qu'une proposition \'{e}l\'{e}mentaire P soit satisfaite dans un monde W. D\'{e}j\`{a}, il faut que P soit bien dans 
   la liste des propositions et W dans la liste des mondes, il suffit que P soit une proposition \'{e}l\'{e}mentaire du monde en question,
   la liste \'{e}tant donn\'{e}e . Cela se d\'{e}finit comme suit :
   \begin{lstlisting}
   satisfait(W, P) :-
     proposition(P),
     monde(W),
     m(W,L),
     member(P,L).
   \end{lstlisting}
   Mais on ne va pas se limiter \`{a} des formules \'{e}l\'{e}mentaire qui ne contiennent que les propositions list\'{e}es. On veut pouvoir utiliser des op\'{e}rateurs.
   Pour cela il faut d'abord les d\'{e}finir avant de d\'{e}finir l'op\'{e}ration correspondante.
   \begin{description}
    \item[la n\'{e}gation (non) :] c'est un op\'{e}rateur de la forme fy auquel on donnera une priorit\'{e} de 200. Pour que 'non P' soit satisfait dans W,
    il faut que W ne fasse pas parti des mondes dans lesquels P est satisfait. Il faut donc d\'{e}terminer la liste des mondes dans lesquels P est satisfait.
       \begin{lstlisting}
   %operateur
   :- op(200, fy, non).
   satisfait(W,non P) :-
     monde(W),
     list_w_satisfait(P, LW), 
     not(member(W, LW)).
   %liste des mondes qui satisfont P
   list_w_satisfait(P, LW) :-
     findall(W,satisfait(W, P), LW).
       \end{lstlisting}
    \item[la conjonction (et) :] c'est un op\'{e}rateur de la forme xfy auquel on donnera une priorit\'{e} de 400. Pour que 'P et Q' soit satisfait dans W,
    il faut que P soit satisfait dans W et que Q soit satisfait dans W.
       \begin{lstlisting}
   %operateur
   :- op(400, xfy, et).
   satisfait(W, P et Q) :-
     monde(W),
     satisfait(W,P),
     satisfait(W,Q).
       \end{lstlisting}
    \item[la disjonction (ou) :] c'est un op\'{e}rateur de la forme xfy auquel on donnera une priorit\'{e} de 400. On utilise ici l'\'{e}criture du 'ou'
    en fonction du 'et et du 'non', en effet 'P ou Q = non(non P et non Q).
       \begin{lstlisting}
   %operateur
   :- op(400, xfy, ou).
   satisfait(W,P ou Q) :-
     satisfait(W, non(non P et non Q)).
       \end{lstlisting}
    \item[l'implication (=>) :] c'est un op\'{e}rateur de la forme xfy auquel on donnera une priorit\'{e} de 300. L'implication se d\'{e}fini par 'non P ou Q'.
       \begin{lstlisting}
   %operateur
   :- op(300, xfy, =>).
   satisfait(W, P => Q) :-
     satisfait(W, non (P et non Q)).
       \end{lstlisting}
    \item[l'\'{e}quivalence (<=>) :] c'est un op\'{e}rateur de la forme xfy auquel on donnera une priorit\'{e} de 300. L'\'{e}quivalence n'est rien d'autre qu'une implication dans
    les deux sens.
       \begin{lstlisting}
   %operateur
   :- op(300, xfy, <=>).
   satisfait(W, P <=> Q) :-
     satisfait(W, P => Q),
     satisfait(W, Q => P).
       \end{lstlisting}
    \item[l'implication stricte (-->>) :] c'est un op\'{e}rateur de la forme xfy auquel on donnera une priorit\'{e} de 300. On a une \'{e}quivalence entre
    'P \-\->> Q' et '\#(P=>Q)', on aura la d\'{e}finition de '\#' un peu plus loin.
       \begin{lstlisting}
   %operateur
   :- op(300, xfy, -->>).
   satisfait(W, P -->> Q) :-
     satisfait(W, #(P => Q)).
       \end{lstlisting}
    \item[la possibilit\'{e} (<>) :] c'est un op\'{e}rateur de la forme fy auquel on donnera une priorit\'{e} de 200. On dit que P est possible dans W s'il existe
    un monde W2 en relation avec W tel que W2 satisfait P. Il faut donc trouver tous les mondes en relation avec W et voir si il y en a au moins un qui satisfait P
       \begin{lstlisting}
   %operateur
   :- op(200, fy, <>).
   satisfait(W, <> P) :-
     monde(W),
     un_rel_satisfait(W,P).
   %une des relations de W satisfait P
   un_rel_satisfait(W, P) :-
     bagof(M, rel(W,M), LM),
     un_satisfait(LM, P).
   %un des éléments de la liste satisfait p
   un_satisfait([M | LM], P) :-
     (satisfait(M,P) -> true; un_satisfait(LM, P)).
       \end{lstlisting}
    \item[la n\'{e}cessarit\'{e} (\#) :] c'est un op\'{e}rateur de la forme fy auquel on donnera une priorit\'{e} de 200. Il se d\'{e}finit ais\'{e}ment \`{a} partir
    de la possibilit\'{e}. En effet '\#P = non(<>(non P))'.
       \begin{lstlisting}
   %operateur
   :- op(200, fy, #).
   satisfait(W, # P) :-
     satisfait(W,non(<>(non P))).
       \end{lstlisting}
   \end{description}
   
   On rappelle que le but est d'\'{e}crire un programme capable de nous lister toutes les formules d'une certaine complexit\'{e} qui sont des th\'{e}oremes ou de nous
   dire si une formule donn\'{e}e est un th\'{e}or\`{e}me.
   
   Pour cela, on veut d\'{e}j\`{a} \^{e}tre capable de g\'{e}n\'{e}rer toutes les formules d'une certaine complexit\'{e}. Une formule de complexit\'{e} 0 n'est qu'un
   proposition et les formules de complexit\'{e} n sont d\'{e}finies r\'{e}cursivement comme une proposition suivie d'un op\'{e}rateur binaire et d'une formule de
   complexit\'{e} n-1 ou juste comme un op\'{e}rateur unaire suivi d'une formule de complexit\'{e} n-1. Le code est donn\'{e} ci-dessous.
   \begin{lstlisting}
   %generation de formules
    genere(P,0):-
      proposition(P).

    genere(F,M):-
      M > 0,
      N is M-1,
      genere(FBIS,N),
      operateur(O),
      proposition(X),
      (O=(=>) -> F=..[O,X,FBIS],F = X=>FBIS;
	O=(<=>) -> F=..[O,X,FBIS],F = X<=>FBIS;
	  O=(et) -> F=..[O,X,FBIS], F = X et FBIS;
	    O=(ou) -> F=..[O,X,FBIS],F = X ou FBIS;
	      O=(-->>) -> F=..[O,X,FBIS],F = X-->>FBIS;
		O=(non) -> F=..[O,X,FBIS],F = non FBIS;
		  O=(<>) -> F=..[O,X,FBIS],F = <> FBIS;
		    O=(#) -> F=..[O,X,FBIS],F = # FBIS).
   \end{lstlisting}
   Enfin, il faut \'{e}crire 'theoreme(P)', si P est une variable, on demande la complexit\'{e} des formules \`{a} g\'{e}n\'{e}rer et on les g\'{e}r\`{e}re
   avant de renvoyer celles qui sont des th\'{e}or\`{e}mes, sinon on v\'{e}rifie juste si P est un th\'{e}oreme. P est un th\'{e}or\`{e}me si il est vrai
   dans tout les mondes existant, pour arriver \`{a} cela, on r\'{e}cup\`{e}re la liste des mondes, celle des mondes dans lesquels P est vrai et on v\'{e}rifie
   qu'ils sont \'{e}gaux.
   \begin{lstlisting}
   %THEOREME : p doit être satisfait dans tous les mondes
   theoreme(P) :-
	(nonvar(P) ->theoreme_aux(P);
	nl,
	write(' complexite : '),
	read(C),
	nl,
	genere(P, C),
	theoreme_aux(P)).

   theoreme_aux(P) :-
	list_w_satisfait(P, LW),
	findall(W,monde(W), ALLW),
	egal(LW, ALLW)
   %l'egalite est une double inclusion
   egal(LW, ALLW) :-
	inclusion(LW, ALLW),
	inclusion(ALLW, LW).

   %inclusion(C,E) est l inclusion de C dans E
   inclusion([], _). %la liste vide est toujours incluse
   inclusion([W|LW], L) :- member(W,L), inclusion(LW,L).
   \end{lstlisting}
   \subsubsection{Tests}
   
  \subsection{TP4 : g\'{e}n\'{e}rateur de plan en logique modale}
  Concernant le TP4, nous n'avons fait que la premi\`{e}re question. Il fallait implanter un g\'{e}n\'{e}rateur de plan en logique modale.
  Le probl\`{e}me \`{a} r\'{e}soudre \'{e}tant :
   \begin{lstlisting}
   ?- est(w0,[p1, ... , pk]), satisfait(<<< Plan >>> (F1 ^ ... ^ Fn), w0).
   \end{lstlisting}
  Nous supposons l'ensemble des mondes connus. Il nous faut trois nouveaux operateurs '<<', '>>' et '::'. Ils sont d\'{e}fini ci-apr\`{e}s.
   \begin{lstlisting}
   %<< a :: b :: c >> (P et Q)
   :- op(100, fy, <<).
   :- op(150, xfy, <<).
   :- op(100, xfy, ::).
   \end{lstlisting}
  Il nous faut donc d\'{e}finir ce que c'est que de satisfaire '<<A>>F' dans le monde W. Ici, soit A est une suite d'actions, soit A est une seule action. Soit X la première action de A
  (si A est une suite) ou A lui-m\^{e}me (si A est une action). Il faut que les conditions de X soient v\'{e}rifi\'{e}es dans le monde de d\'{e}part W $est\_entrepeunable(A, W)$,
  il faut ensuite trouver un monde W2 dans lequel les effets de A sont effectifs $est\_effective(A, W)$. Enfin, si A est une action, il faut que F soit satisfait
  dans W2, sinon si A est une suite d'actions 'X::ABIS', il faut que '<<ABIS>>F soit satisfait dans W2. Le code est donn\'{e} ci-dessous.
  \begin{lstlisting}
   satisfait(W, << A >> F) :-
	monde(W),
	rel(W, W2), % \E un monde W2
        operateur_act(O),
        (O=(::) -> A=..[O,X,ABIS], %si on a une suite d'actions
                   A = X::ABIS, 
                   est_entrepenable(X, W),
	           est_effective(X, W2),
                   satisfait(W2, <<ABIS>> F);
         est_entrepenable(A, W), %si A est une action
	 est_effective(A, W2),
	 satisfait(W2, F)). % F est satisfait dans W2
   \end{lstlisting}
   Il faut donc d\'{e}finir est\_entrepenable et est\_effective. $est\_entrepeunable(A, W)$ permet de v\'{e}rifier que les conditions de A sont satisfaites dans W,
   pour cela, il faut r\'{e}cup\'{e}rer la liste des conditions, la convertir en conjonction de ses diff\'{e}rents \'{e}l\'{e}ments avant de voir si cette conjonction
   est satisfaite dans W. Pour $est\_effective(A, W)$, c'est le m\^{e}me principe mais on prend la n\'{e}gation de la conjonction des effets.
    \begin{lstlisting}
   satisfait(W, << A >> F) :-
	monde(W),
	rel(W, W2), % \E un monde W2
        operateur_act(O),
        (O=(::) -> A=..[O,X,ABIS], %si on a une suite d'actions
                   A = X::ABIS, 
                   est_entrepenable(X, W),
	           est_effective(X, W2),
                   satisfait(W2, <<ABIS>> F);
         est_entrepenable(A, W), %si A est une action
	 est_effective(A, W2),
	 satisfait(W2, F)). % F est satisfait dans W2
   \end{lstlisting}
   
   
 \section{Travaux r\'{e}alis\'{e}s lors du bureau d'\'{e}tude}
 
  \subsection{Etude de Lm\{p\} }
  
  \subsection{Etude de Lm\{E0\}}
  
  \subsection{Etude d'autres logiques}
  
 \section{Conclusion}
    
\end{document}